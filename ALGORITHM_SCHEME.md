# Алгоритмическая схема системы мониторинга портов (ИИ создание схем, наполнение информацией вручную)

## 1. Общая архитектура системы

```
┌─────────────────────────────────────────────────────────────────┐
│         PORT SCANNER - Многопоточное сканирование портов        │
└─────────────────────────────────────────────────────────────────┘
                            ▼
        ┌────────────────────────────────────────┐
        │    Загрузка конфигурации (Config)      │
        │  - Целевые адреса и диапазоны портов   │
        │  - Параметры Masscan (rate, timeout)   │
        │  - Данные Telegram (token, chat_id)    │
        │  - Режим сканирования (расписание)     │
        └────────────────────────────────────────┘
                            ▼
        ┌────────────────────────────────────────┐
        │    Выбор режима сканирования           │
        └────────────────────────────────────────┘
                            ▼
              ┌─────────────┴────────────────┐
              ▼                              ▼
    ┌──────────────────┐          ┌──────────────────────┐
    │ Одноразовое      │          │  Плановое            │
    │ сканирование     │          │  (по расписанию)     │
    │ schedule.enabled │          │ schedule.enabled     │
    │ = false          │          │ = true               │
    └──────────────────┘          └──────────────────────┘
              ▼                              ▼
        Запуск 1 раз              Вечный цикл с интервалом
        Отправить                 Отправить уведомление
        2 сообщения:              о начале (все цели)
        1. Start                  Далее циклично:
        2. Results                - Полное сканирование
                                  - Только изменения
```

## 2. Поток данных и компоненты

```
Система состоит из 8 основных компонентов:

┌─────────────────────────────────────────────────────────────┐
│ 1. Setup_Logging()                                          │
│    Инициализация логирования (файл + консоль)               │
└─────────────────────────────────────────────────────────────┘
                            ▼
┌─────────────────────────────────────────────────────────────┐
│ 2. Config (class)                                           │
│    - Загрузка app/config.json                               │
│    - Валидация параметров                                   │
│    - Предоставление свойств для доступа                     │
└─────────────────────────────────────────────────────────────┘
                            ▼
┌─────────────────────────────────────────────────────────────┐
│ 3. TelegramNotifier (class)                                 │
│    - Инициализация Bot с токеном                            │
│    - 8 методов отправки разных типов сообщений              │
│    - Async + sync fallback при CancelledError               │
└─────────────────────────────────────────────────────────────┘
                            ▼
┌─────────────────────────────────────────────────────────────┐
│ 4. MasscanScanner (class)                                   │
│    - Проверка установки Masscan                             │
│    - Запуск сканирования на базе rate/timeout               │
│    - Парсинг JSON-вывода                                    │
│    - Возврат списка {ip, port, protocol, status}            │
└─────────────────────────────────────────────────────────────┘
                            ▼
┌─────────────────────────────────────────────────────────────┐
│ 5. BannerGrabber (class)                                    │
│    - Инициализация Nmap с оптимизованными параметрами       │
│    - Сканирование всех портов ОДНОЙ операцией (ускорение)   │
│    - Извлечение: service_name, product, version, extrainfo  │
│    - Возврат {port: service_info}                           │
└─────────────────────────────────────────────────────────────┘
                            ▼
┌─────────────────────────────────────────────────────────────┐
│ 6. ScanHistory (class)                                      │
│    - Загрузка истории из app/scan_history/scan_history.json │
│    - Сохранение новых результатов                           │
│    - Определение новых портов                               │
│    - Определение измененных сервисов                        │
└─────────────────────────────────────────────────────────────┘
                            ▼
┌─────────────────────────────────────────────────────────────┐
│ 7. PortScannerOrchestrator (class)                          │
│    - Координирует работу всех компонентов                   │
│    - run_scheduled_scans() - основной цикл                  │
│    - run_all_scans() - сканирование всех целей              │
│    - run_scan() - сканирование одной цели                   │
│    - process_scan_result() - обработка результатов          │
└─────────────────────────────────────────────────────────────┘
                            ▼
┌─────────────────────────────────────────────────────────────┐
│ 8. main() async                                             │
│    - Точка входа программы                                  │
│    - Создание Orchestrator                                  │
│    - Запуск run_scheduled_scans()                           │
└─────────────────────────────────────────────────────────────┘
```

## 3. Алгоритм одноразового сканирования (одна цель)

```
ШАГ 1: Инициализация
├─ Загрузить config.json
├─ Проверить установку Masscan и Nmap
└─ Инициализировать Telegram бота

ШАГ 2: Оповещение о начале
└─ Отправить в Telegram:
   "Начало сканирования! Цель: [name], Адрес: [target], Порты: [ports]"

ШАГ 3: Сканирование Masscan
├─ Построить команду: masscan [target] -p [ports] --rate [rate] --open-only --output-format json
├─ Выполнить сканирование
├─ Парсить JSON результаты
└─ Вернуть список открытых портов: [{ip, port, protocol, status}, ...]

ШАГ 4: Получение баннеров (для каждого IP)
├─ Сгруппировать порты по IP
├─ Для каждого IP с открытыми портами:
│  ├─ Запустить Nmap: nmap [ip] -p [ports] -sV --version-intensity=0 -T5
│  ├─ Парсить результаты (service, product, version, extrainfo)
│  └─ Вернуть {port: full_service_info}
└─ Все порты одного IP сканируются за Одну операцию

ШАГ 5: Сравнение с историей
├─ Загрузить историю из файла
├─ Для каждого IP определить:
│  ├─ Новые порты = текущие - исторические
│  └─ Измененные сервисы = изменилась версия сервиса
└─ Сохранить текущее состояние в историю

ШАГ 6: Отправка результатов
├─ Составить полное сообщение с результатами:
│  ├─ Цель сканирования
│  ├─ Адрес
│  ├─ Все найденные порты и сервисы
│  └─ Время сканирования
└─ Отправить в Telegram

ШАГ 7: Завершение
└─ Выход программы (exit code = 0)
```

## 4. Алгоритм планового сканирования (расписание)

```
ШАГ 1: Инициализация (как в одноразовом)
└─ Загрузить конфиг, проверить Masscan/Nmap, инициализировать Telegram

ШАГ 2: Оповещение о начале расписания
├─ Если одна цель: отправить компактное уведомление
└─ Если несколько целей: отправить уведомление со списком всех целей
   "Начало планового сканирования!
    Количество целей: N
    Интервал: каждые M часов
    
    Цели:
    1. [name] - [address] - [ports]
    2. [name] - [address] - [ports]
    ..."

ШАГ 3: Вечный цикл сканирания
┌─ WHILE TRUE:
│  ├─ total_cycles += 1
│  ├─ ШАГ 4-5 (для каждой цели):
│  │  ├─ Сканирование Masscan (как в одноразовом)
│  │  ├─ Получение баннеров Nmap (как в одноразовом)
│  │  ├─ Сравнение с историей
│  │  └─ Отправка только об ИЗМЕНЕНИЯХ (новые порты, измененные сервисы)
│  │      НЕ отправляем уведомление, если нет изменений!
│  │
│  ├─ Подсчет статистики (scan_count, total_cycles)
│  ├─ Вычисление времени следующего сканирования
│  └─ await asyncio.sleep(interval_seconds)
│
└─ До Ctrl+C

ШАГ 6: Обработка Ctrl+C (KeyboardInterrupt)
├─ Поймать исключение в try-except
├─ Логировать: "Сканирование остановлено пользователем"
├─ Отправить финальное уведомление:
│  "Плановое сканирование остановлено!
│   Завершено циклов: M
│   Проведено проверок портов: K
│   Время остановки: YYYY-MM-DD HH:MM:SS"
└─ Выход программы (exit code = 0)
```

## 5. Структуры данных

### config.json
```json
{
  "scan_target": [
    {
      "name": "Google DNS",
      "target": "8.8.8.8",
      "ports": "1-1000"
    },
    {
      "name": "Cloudflare DNS",
      "target": "1.1.1.1",
      "ports": "1-1000"
    }
  ],
  "masscan_config": {
    "rate": 100000,
    "timeout": 30
  },
  "telegram": {
    "bot_token": "...",
    "chat_id": "..."
  },
  "schedule": {
    "enabled": true,
    "interval_hours": 24
  }
}
```

### scan_history.json
```json
{
  "8.8.8.8": {
    "first_scanned": "2026-01-30 10:15:30",
    "last_scanned": "2026-01-30 10:45:30",
    "ports": [53, 80, 443],
    "services": {
      "53": "dns ISC BIND nameserver",
      "80": "http",
      "443": "https"
    }
  },
  "1.1.1.1": {
    "first_scanned": "2026-01-30 10:15:30",
    "last_scanned": "2026-01-30 10:45:30",
    "ports": [80, 443],
    "services": {
      "80": "http Cloudflare",
      "443": "https Cloudflare"
    }
  }
}
```

### Masscan результат (пример)
```json
{"ip": "8.8.8.8", "timestamp": "1234567890", "ports": [{"port": 53, "proto": "tcp", "status": "open"}]}
{"ip": "8.8.8.8", "timestamp": "1234567890", "ports": [{"port": 80, "proto": "tcp", "status": "open"}]}
```

### Nmap результат (парсится в BannerGrabber)
```
8.8.8.8:
53/tcp   open dns ISC BIND 9.16.1
80/tcp   open http
443/tcp  open https
```

## 6. Обработка ошибок

```
┌──────────────────────────────────────────────────────────────────┐
│ Возможные ошибки и их обработка                                  │
└──────────────────────────────────────────────────────────────────┘

1. Config не найден или невалиден
   ├─ FileNotFoundError → logging.error() + sys.exit(1)
   └─ JSONDecodeError → logging.error() + sys.exit(1)

2. Masscan не установлен
   ├─ subprocess.CalledProcessError → logging.error() + sys.exit(1)
   └─ FileNotFoundError → logging.error() + sys.exit(1)

3. Nmap ошибка при сканировании
   ├─ nmap.PortScannerError → logging.warning() + вернуть "Ошибка сканирования"
   └─ Общее исключение → logging.debug() + вернуть "Ошибка при сканировании"

4. Telegram недоступен
   ├─ asyncio.CancelledError → синхронная отправка через requests.post()
   └─ Общее исключение → logging.error()

5. Ctrl+C (KeyboardInterrupt)
   ├─ Перехватить в try-except в run_scheduled_scans()
   ├─ Отправить финальное уведомление
   └─ Корректный выход

6. Ошибка парсинга JSON (Masscan)
   ├─ Пропустить строку
   ├─ logging.debug()
   └─ Продолжить обработку следующих строк

7. Timeout asyncio.sleep()
   ├─ Перехватить CancelledError
   ├─ Преобразовать в KeyboardInterrupt
   └─ Отправить уведомление
```

## 7. Диаграмма потока данных за один цикл

```
                    START
                      │
                      ▼
        ┌─────────────────────────────┐
        │   Загрузить конфиг          │
        └─────────────────────────────┘
                      │
                      ▼
        ┌─────────────────────────────┐
        │   Отправить уведомление     │
        │   "Начало сканирования"     │
        └─────────────────────────────┘
                      │
                      ▼
              ┌───────────────┐
              │ Masscan       │
              │ сканирование  │ 
              │               │
              └───────────────┘
                      │
                      ▼
             ┌────────────────┐
             │ Nmap баннеры   │
             │ (5-10 сек)     │
             └────────────────┘
                      │
                      ▼
        ┌─────────────────────────────┐
        │  Сравнение с историей       │
        │  (найти изменения)          │
        └─────────────────────────────┘
                       │
                       ▼
        ┌─────────────────────────────┐
        │  Отправить уведомления      │
        │  (о новых портах/сервисах)  │
        └─────────────────────────────┘
                       │
                       ▼
        ┌─────────────────────────────┐
        │  Сохранить в историю        │
        │  (update scan_history.json) │
        └─────────────────────────────┘
                       │
      ┌────────────────┴────────────────┐
      ▼                                 ▼
   ОДНОРАЗОВОЕ              ПЛАНОВОЕ (расписание)
   Выход (EXIT)             Ожидание interval_hours
                            Возврат на START
```